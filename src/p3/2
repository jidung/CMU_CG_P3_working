/**
 * @file raytacer.cpp
 * @brief Raytracer class
 *
 * Implement these functions for project 4.
 *
 * @author H. Q. Bovik (hqbovik)
 * @bug Unimplemented
 */

// for debugging. jd
//#define NORMAL_SHADING

#include "raytracer.hpp"
#include "scene/scene.hpp"
#include "math/quickselect.hpp"
#include "p3/randomgeo.hpp"
#include <SDL_timer.h>

// added by m.ji
#include <typeinfo>
#include "scene/triangle.hpp"
#include "scene/sphere.hpp"
#include "scene/model.hpp"
namespace _462 {


//number of rows to render before updating the result
static const unsigned STEP_SIZE = 1;
static const unsigned CHUNK_SIZE = 1;

Raytracer::Raytracer() {
        scene = 0;
        width = 0;
        height = 0;
    }

Raytracer::~Raytracer() { }

/**
 * Initializes the raytracer for the given scene. Overrides any previous
 * initializations. May be invoked before a previous raytrace completes.
 * @param scene The scene to raytrace.
 * @param width The width of the image being raytraced.
 * @param height The height of the image being raytraced.
 * @return true on success, false on error. The raytrace will abort if
 *  false is returned.
 */
bool Raytracer::initialize(Scene* scene, size_t num_samples,
               size_t width, size_t height)
{
    this->scene = scene;
    this->num_samples = num_samples;
    
    //this->num_samples = 3; // temp code. jd
    this->width = width;
    this->height = height;

    current_row = 0;

    projector.init(scene->camera);
    scene->initialize();
    photonMap.initialize(scene);
    return true;
}
//compute ambient lighting
Color3 Raytracer::trace_ray(Ray &ray, const unsigned int &depth/*maybe some more arguments*/){

    Ray newRay;
    real_t interTime = 99999.;   // will get intersection time
    real_t minInterTime = 999999.;   // will get intersection time
    bool hit = false;
    Geometry* const* geometries = scene->get_geometries();
    //Material* const* materials = scene->get_materials();
    Vector3 normal;
    uint hitGeometryIdx;

    Triangle* tri;
    Sphere* sphere;
    Model* model;

    Color3 color (0,0,0);
    Color3 reflectionColor (0,0,0);

    //std::cout << depth << std::endl;

    for (unsigned int i = 0; i < scene->num_geometries(); ++i) {
        /* instancing not working well. moving on */

        newRay = ray.translate (geometries[i]->invMat);

        // ray hit object in the object's local space
        if ( geometries[i]->intersect (newRay, interTime) ) {
            //if (minInterTime > interTime && interTime > EPS) {
            if (minInterTime > interTime) {
                hit = true;
                minInterTime = interTime;
                hitGeometryIdx = i;
            }
        }
    }
           
    if (hit) {

        if (depth < MAX_DEPTH) {
            // only for spheres
            normal = geometries[hitGeometryIdx]->computeNormal (ray.atTime(minInterTime)); 

            normal = normalize(normal);
            tri = (dynamic_cast<Triangle*>(geometries[hitGeometryIdx]));
            sphere = (dynamic_cast<Sphere*>(geometries[hitGeometryIdx]));
            model = (dynamic_cast<Model*>(geometries[hitGeometryIdx]));

            if (tri != NULL)
                color = tri->vertices[1].material->diffuse * dot(normal, -ray.d);
            else if (sphere != NULL)
                color = sphere->material->diffuse * dot(normal, -ray.d);
            else if (model != NULL)
                color = model->material->diffuse * dot(normal, -ray.d);
            else
                color = Color3 (1.0,0.0,0.0);

#ifdef NORMAL_SHADING            
            color.r = abs(normal.x);
            color.g = abs(normal.y);
            color.b = abs(normal.z);
#endif

            std::cout << normal << std::endl;

            Ray reflectRay;
            reflectRay = ray.reflect(ray.atTime(minInterTime), normal);

           // reflectionColor = trace_ray(reflectRay, depth + 1);

            color += reflectionColor;
        } 
    }
    
    
    return color;

    // original code
    //TODO: render something more interesting
    // return Color3(fabs(sin(10*ray.d.x)),fabs(10*cos(ray.d.y)),fabs(10*tan(ray.d.y)));
}

/**
 * Performs a raytrace on the given pixel on the current scene.
 * The pixel is relative to the bottom-left corner of the image.
 * @param scene The scene to trace.
 * @param x The x-coordinate of the pixel to trace.
 * @param y The y-coordinate of the pixel to trace.
 * @param width The width of the screen in pixels.
 * @param height The height of the screen in pixels.
 * @return The color of that pixel in the final image.
 */
Color3 Raytracer::trace_pixel(size_t x,
                  size_t y,
                  size_t width,
                  size_t height)
{
    assert(x < width);
    assert(y < height);

    real_t dx = real_t(1)/width;
    real_t dy = real_t(1)/height;

    Color3 res = Color3::Black();
    unsigned int iter;

    unsigned int depth = 0;

    for (iter = 0; iter < num_samples; iter++)
    {
        // pick a point within the pixel boundaries to fire our
        // ray through.
        real_t i = real_t(2)*(real_t(x)+random_uniform())*dx - real_t(1);
        real_t j = real_t(2)*(real_t(y) + random_uniform())*dy - real_t(1);

        Ray r = Ray(scene->camera.get_position(), projector.get_pixel_dir(i, j));
    
        res += trace_ray(r, depth);
        // TODO return the color of the given pixel
        // you don't have to use this stub function if you prefer to
        // write your own version of Raytracer::raytrace.

    }
    return res*(real_t(1)/num_samples);
}

/**
 * Raytraces some portion of the scene. Should raytrace for about
 * ax_time duration and then return, even if the raytrace is not copmlete.
 * The results should be placed in the given buffer.
 * @param buffer The buffer into which to place the color data. It is
 *  32-bit RGBA (4 bytes per pixel), in row-major order.
 * @param max_time, If non-null, the maximum suggested time this
 *  function raytrace before returning, in seconds. If null, the raytrace
 *  should run to completion.
 * @return true if the raytrace is complete, false if there is more
 *  work to be done.
 */
bool Raytracer::raytrace(unsigned char* buffer, real_t* max_time)
{
    
    static const size_t PRINT_INTERVAL = 64;

    // the time in milliseconds that we should stop
    unsigned int end_time = 0;
    bool is_done;

    if (max_time)
    {
        // convert duration to milliseconds
        unsigned int duration = (unsigned int) (*max_time * 1000);
        end_time = SDL_GetTicks() + duration;
    }

    // until time is up, run the raytrace. we render an entire group of
    // rows at once for simplicity and efficiency.
    for (; !max_time || end_time > SDL_GetTicks(); current_row += STEP_SIZE)
    {
        // we're done if we finish the last row
        is_done = current_row >= height;
        // break if we finish
        if (is_done) break;

        int loop_upper = std::min(current_row + STEP_SIZE, height);

        for (int c_row = current_row; c_row < loop_upper; c_row++)
        {
            /*
             * This defines a critical region of code that should be
             * executed sequentially.
             */
#pragma omp critical
            {
                if (c_row % PRINT_INTERVAL == 0)
                    printf("Raytracing (Row %d)\n", c_row);
            }
            
        // This tells OpenMP that this loop can be parallelized.
#pragma omp parallel for schedule(dynamic, CHUNK_SIZE)
            for (size_t x = 0; x < width; x++)
            {
                // trace a pixel
                Color3 color = trace_pixel(x, c_row, width, height);
                // write the result to the buffer, always use 1.0 as the alpha
                color.to_array4(&buffer[4 * (c_row * width + x)]);
            }
#pragma omp barrier

        }
    }

    if (is_done) printf("Done raytracing!\n");

    return is_done;
}

} /* _462 */
